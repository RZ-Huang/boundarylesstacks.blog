---
import * as themeConstants from '@/constants/theme';
import { getDefaultThemes } from '@/utils/theme';

const defaultThemes = getDefaultThemes();
---

{/* Inlined to avoid flash of white content. */}
<script is:inline define:vars={{ themeConstants, defaultThemes }}>
  // this is JavaScript, not TypeScript
  const { MODES, THEMES, THEME_CONFIG } = themeConstants;
  const { DATA_ATTRIBUTE, CHANGE_EVENT, LOCAL_STORAGE_KEY } = THEME_CONFIG;

  const darkModePreference = window.matchMedia('(prefers-color-scheme: dark)');

  // 1. stored mode
  // 2. default app mode, config
  // 3. OS mode

  // light is default
  const getMode = (themeMode) => (themeMode === MODES.dark ? MODES.dark : MODES.light);

  const getDefaultTheme = (themeMode) => defaultThemes[getMode(themeMode)];

  const setMode = (themeMode) => {
    const storedTheme = getStoredTheme();

    if (!storedTheme) return getDefaultTheme(themeMode);

    const newTheme = { ...storedTheme, mode: getMode(themeMode) };
    return newTheme;
  };

  const getOSMode = () => (darkModePreference.matches ? MODES.dark : MODES.light);

  const getOSTheme = () => {
    const themeMode = getOSMode();
    const defaultOSTheme = getDefaultTheme(themeMode);

    return defaultOSTheme;
  };

  const getTheme = () => {
    // either from storage
    const storedTheme = getStoredTheme();
    if (storedTheme) return storedTheme;

    // or fallback to default theme for OS mode
    const defaultOSTheme = getOSTheme();
    return defaultOSTheme;
  };

  const getStoredTheme = () => {
    const storedThemeString =
      typeof localStorage !== 'undefined' && localStorage.getItem(LOCAL_STORAGE_KEY);

    if (!storedThemeString) return null;

    let storedTheme;
    try {
      storedTheme = JSON.parse(storedThemeString);
    } catch (_error) {
      localStorage.removeItem(LOCAL_STORAGE_KEY);
      return null;
    }

    // invalid theme
    if (!(storedTheme && storedTheme.name && storedTheme.mode)) {
      // clear stored invalid theme
      localStorage.removeItem(LOCAL_STORAGE_KEY);
      return null;
    }

    return storedTheme;
  };

  const setTheme = (newTheme) => {
    const validatedTheme = THEMES.find(
      (theme) => theme.name === newTheme.name && theme.mode === newTheme.mode
    );

    if (!validatedTheme)
      return console.warn(
        `Invalid theme value '${JSON.stringify(newTheme)}' received. Expected ${JSON.stringify(THEMES)}.`
      );

    const root = document.documentElement;

    const isDarkMode = root.classList.contains(MODES.dark);
    const existingTheme = {
      name: root.getAttribute(DATA_ATTRIBUTE),
      mode: isDarkMode ? MODES.dark : MODES.light,
    };
    const isExistingTheme =
      newTheme.name === existingTheme.name && newTheme.mode === existingTheme.mode;

    // root already set to newTheme, exit early
    if (isExistingTheme) return;

    // update root class and data-theme
    root.setAttribute(DATA_ATTRIBUTE, newTheme.name);
    if (newTheme.mode === MODES.dark) {
      // dark
      if (!isDarkMode) root.classList.add(MODES.dark);
    } else {
      // light
      if (isDarkMode) root.classList.remove(MODES.dark);
    }

    if (typeof localStorage !== 'undefined') {
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(newTheme));
    }
  };

  // initial setup
  setTheme(getTheme());

  // View Transitions hook to restore theme
  document.addEventListener('astro:after-swap', () => setTheme(getTheme()));

  // listen for theme-change custom event, fired in src/components/ThemeToggle.astro
  document.addEventListener(CHANGE_EVENT, (event) => {
    setTheme(event.detail.theme);
  });

  // listen for prefers-color-scheme change
  darkModePreference.addEventListener('change', (event) => {
    const newMode = event.matches ? MODES.dark : MODES.light;
    const newTheme = setMode(newMode);
    setTheme(newTheme);
  });
</script>
